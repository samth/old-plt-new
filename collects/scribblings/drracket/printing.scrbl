#lang scribble/doc
@(require "common.ss"
          scribble/struct)

@(define spacer (hspace 1))

@(define-syntax-rule (print-table [expr cons qq wr] ...)
  (*print-table (list (list spacer (racket expr) spacer (racketresult cons) spacer (racketresult qq) spacer (racketresult wr)) ...)))

@(define (*print-table rows)
   (make-table
    #f
    (cons
     (list (make-flow (list (make-paragraph (list spacer))))
           (make-flow (list @t{Input expression}))
           (make-flow (list (make-paragraph (list spacer))))
           (make-flow (list @t{@onscreen{Constructor}}))
           (make-flow (list (make-paragraph (list spacer))))
           (make-flow (list @t{@onscreen{Quasiquote}}))
           (make-flow (list (make-paragraph (list spacer))))
           (make-flow (list @t{@onscreen{write}})))
     (map (lambda (row)
            (map (lambda (e)
                   (make-flow (list (make-paragraph (list e)))))
                 row))
          rows))))

@title[#:tag "output-syntax"]{Output Printing Styles}

@section-index["printing format"]

Many Racket languages support a @onscreen{Output Syntax} choice that
determines how evaluation results are printed in the
@tech{interactions window}. This setting also applies to output
generated by calling @racket[print] explicitly.

The following table illustrates the difference between the different
output styles:

@print-table[
[(cons 1 2) (cons 1 2) `(1 . 2) (1 . 2)]
[(list 1 2) (list 1 2) `(1 2) (1 2)]
['(1 2) (list 1 2) `(1 2) (1 2)]
[(list (void)) (list (void)) `(,(void)) (#,(@racketresultfont "#<void>"))]
[`(,(void)) (list (void)) `(,(void)) (#,(racketresultfont "#<void>"))]
[(vector 1 2 3) (vector 1 2 3) (vector 1 2 3) #(1 2 3)]
[(box 1) (box 1) (box 1) #&1]
[(lambda (x) x) (lambda (a1) ...) (lambda (a1) ...) #,(racketresultfont "#<procedure>")]
['sym 'sym 'sym sym]
[(make-s 1 2) (make-s 1 2) (make-s 1 2) #(struct:s 1 2)]
['() empty `() ()]
[add1 add1 add1 #,(racketresultfont "#<procedure:add1>")]
[(delay 1) (delay ...) (delay ...) #,(racketresultfont "#<promise>")]
[(regexp "a") (regexp "a") (regexp "a") #rx"a"]
]

The @as-index{@onscreen{Constructor} output} mode treats
@racket[cons], @racket[vector], and similar primitives as value
constructors, rather than functions. It also treats @racket[list] as
shorthand for multiple @racket[cons]'s ending with the empty list.
@onscreen{Constructor} output is especially valuable for beginning
programmers, because output values look the same as input values.

The @as-index{@onscreen{Quasiquote} output} mode is like
@onscreen{Constructor} output, but it uses @racket[quasiquote]
(abbreviated with @litchar{`}) to print lists, and it uses
@racket[unquote] (abbreviated with @litchar{,}) to escape back to
@onscreen{Constructor} printing as needed. This mode provides the same
benefit as @onscreen{Constructor} output, in that printed results are
expressions, but it is more convenient for many kinds of data,
especially data that represents expressions.

The @as-index{@onscreen{write} output} mode corresponds to traditional
Scheme printing via the @racket[print] procedure, which defaults to
@racket[write]-like printing, as shown in the last column.

DrRacket also sets the @racket[global-port-print-handler] in order to
customize a few aspects of the printing for all of these modes, namely
printing the symbol @racket[quote] as a single tick mark (mutatis
mutandis for @racket[quasiquote], @racket[unquote], and
@racket[unquote-splicing]), and to print rational real numbers using a
special @racket[snip%] object that lets the user choose between
improper fractions, mixed fractions, and repeating decimals.
