#reader(lib "docreader.ss" "scribble")
@require[(lib "bnf.ss" "scribble")]
@require["mz.ss"]

@define[(FmtMark . s) (apply litchar "~" s)]

@title{Writing}

@defproc[(write [datum any/c][out output-port? (current-output-port)])
         void?]{

Writes @scheme[datum] to @scheme[out], normally in such a way that
instances of core datatypes can be read back in. If @scheme[out] has a
handler associated to it via @scheme[port-write-handler], then the
handler is called. Otherwise, the default printer is used (in
@scheme[write] mode), as configured by various parameters.

See @secref["mz:printer"] for more information about the default
printer.}

@defproc[(display [datum any/c][out output-port? (current-output-port)])
         void?]{

Displays @scheme[datum] to @scheme[out], similar to @scheme[write],
but usually in such a way that byte- and character-based datatypes are
written as raw bytes or characters. If @scheme[out] has a handler
associated to it via @scheme[port-display-handler], then the handler
is called. Otherwise, the default printer is used (in @scheme[display]
mode), as configured by various parameters.

See @secref["mz:printer"] for more information about the default
printer.}

@defproc[(print [datum any/c][out output-port? (current-output-port)])
         void?]{

Writes @scheme[datum] to @scheme[out], normally the same way as
@scheme[write]. If @scheme[out] has a handler associated to it via
@scheme[port-print-handler], then the handler is called. Otherwise,
the handler specified by @scheme[global-port-print-handler] is called;
the default handler uses the default printer in @scheme[write] mode.

The rationale for providing @scheme[print] is that @scheme[display]
and @scheme[write] both have relatively standard output conventions,
and this standardization restricts the ways that an environment can
change the behavior of these procedures. No output conventions should
be assumed for @scheme[print], so that environments are free to modify
the actual output generated by @scheme[print] in any way.}


@defproc[(fprintf [out output-port?][form string?][v any/c] ...) void?]{

Prints formatted output to @scheme[out], where @scheme[form] is a string
that is printed directly, except for special formatting
escapes:

@itemize{

  @item{@FmtMark{n} or @FmtMark{%} prints a newline}

  @item{@FmtMark{a} or @FmtMark{A} @scheme[display]s the next argument
  among the @scheme[v]s}

  @item{@FmtMark{s} or @FmtMark{S} @scheme[write]s the next argument
  among the @scheme[v]s}

  @item{@FmtMark{v} or @FmtMark{V} @scheme[print]s the next argument
  among the @scheme[v]s}
 
  @item{@FmtMark{e} or @FmtMark{E} outputs the next argument among the
  @scheme[v]s using the current error value conversion handler (see
  @scheme[error-value->string-handler]) and current error printing
  width} @item{@FmtMark{c} or @FmtMark{C} @scheme[write-char]s the
  next argument in @scheme[v]s; if the next argument is not a
  character, the @exnraise[exn:fail:contract]}

  @item{@FmtMark{b} or @FmtMark{B} prints the next argument among the
  @scheme[v]s in binary; if the next argument is not an exact number, the
  @exnraise[exn:fail:contract]}

  @item{@FmtMark{o} or @FmtMark{O} prints the next argument among the
  @scheme[v]s in octal; if the next argument is not an exact number, the
  @exnraise[exn:fail:contract]}

  @item{@FmtMark{x} or @FmtMark{X} prints the next argument among the
  @scheme[v]s in hexadecimal; if the next argument is not an exact
  number, the @exnraise[exn:fail:contract]}

  @item{@FmtMark{~} prints a tilde.}

  @item{@FmtMark{}@nonterm{w}, where @nonterm{w} is a whitespace character,
  skips characters in @scheme[form] until a non-whitespace
  character is encountered or until a second end-of-line is
  encountered (whichever happens first). An end-of-line is either
  @scheme[#\return], @scheme[#\newline], or @scheme[#\return] followed
  immediately by @scheme[#\newline] (on all platforms).}

}

The @scheme[form] string must not contain any @litchar{~} that is
not one of the above escapes, otherwise the
@exnraise[exn:fail:contract]. When the format string requires more
@scheme[v]s than are supplied, the
@exnraise[exn:fail:contract]. Similarly, when more @scheme[v]s are
supplied than are used by the format string, the
@exnraise[exn:fail:contract].

@examples[
(fprintf (current-output-port)
         "~a as a string is ~s.~n"
         '(3 4) 
         "(3 4)")
]}

@defproc[(printf [form string?][v any/c] ...) void?]{
The same as @scheme[(fprintf (current-output-port) form v ...)].}

@defproc[(format [form string?][v any/c] ...) string?]{
Formats to a string. The result is the same as

@schemeblock[
(let ([o (open-output-string)])
  (fprintf o form v ...)
  (get-output-string o))
]

@examples[
(format "~a as a string is ~s.~n" '(3 4) "(3 4)")
]}
