_Honu_

_TODO_

  * Admit statements as elements of mixin bodies, i.e., 

     struct ExamplesC() : Examples {
      IStack s0 = new StackC();
      int d0 = s0.depth();
      s0.push(s0);
     }

    should work. -- MF

  * Work out details of standard library, including boxed versions of
    primitive types.

  * If you do have a standard library, document it please. -- MF 

  * Let's add arrays. 

  * Add new statement that uses positional initialization arguments.

  * Add autoboxing of primitive types.

  * Add generics (parametric polymorphism and bounded polymorphism).
    RESEARCH! 

_Primitive types_

  int    - integers
  float  - floating point numbers
  string - strings    (double quoted)
  bool   - booleans   (true, false)
  char   - characters (single quoted)

_Built-in functions_

Error reporting:

> error(string message) => 'a
    - Raises an error and prints the string as an error message.
    - Calls to error() do not return.

Input/output:

> printString(string message) => void
    - Takes a string and prints it on the standard output.

> printLine(string message) => void
    - Like printString, but prints a newline after printing the string.

> readChar() => char
    - Reads a single character from the standard input.

> readLine() => string
    - Reads a line of text from the standard input.

Conversions to string:

> intToString(int val) => string
    - Converts an integer to a string.

> floatToString(float val) => string
    - Converts a floating point number to a string.

> charToString(char val) => string
    - Converts a character to a string.

String conversions:

> stringToInt(string val) => int
    - Converts a string to an integer.
    - Raises an error if the string cannot be converted.

> stringToFloat(string val) => float
    - Converts a string to a floating point number.
    - Raises an error if the string cannot be converted.

String operations:

> strlen(string s) => int
    - Takes a string and returns the string length.

> substr(string s, int start, int end) => string
    - Takes a string, a start index, and an end index and
      returns the corresponding substring.
    - The indexes are zero-based.
    - The start index cannot be negative or greater than the end index.
    - The end index must be less than or equal to the string length.

> charAt(string s, int i) => char
    - Takes a string and an index into the string and returns
      the corresponding character.
    - The zero-based index cannot be negative and must be less
      than the string length.

_Grammar_

NOTE: Since I want to use parentheses to mean "real" parentheses, I use
      square brackets for grouping inside of rules.

<program>  ::= <defn>*

<defn>     ::= <function>
             | <top-bind>
             | <type>
             | <class>
             | <mixin>
             | <subclass>

<top-bind> ::= <bind> = <expr> ;
             | ( <bind> [, <bind>]* ) = <expr>;

<bind>     ::= <tid> <id>
             | _

<function> ::= <tid> <id> ( <argdecls> ) <block>

<tid>      ::= <ifacet>
             | <primtype>
             | <funtype>
             | <tuptype>

<funtype>  ::= <tid> -> <tid>

<tuptype>  ::= < >
             | < <tid> [, <tid>]* >

<ifacet>   ::= id
             | Any

<primtype> ::= int
             | float
             | bool
             | str
             | char
             | void

<type>     ::= type <id> <extends> { <mfdecl>* }
             | interface <id> <extends> { <mfdecl>* }

<extends>  ::= extends <ifacet> [, <ifacet>]*
             | <: <ifacet> [, <ifacet>]*
             |

<mfdecl>   ::= <tid> <fdid> ;
             | <tid> <mdid> ( <argdecls>* ) ;

<argdecls> ::= <argdecl> [, <argdecl>]*
             |

<argdecl>  ::= <tid>
             | <tid> <varid>

<struct>   ::= struct <id> <initargs> : <ifacet> <impls> <clsbody>
             | final struct <id> <initargs> : <ifacet> <impls> <clsbody>
             | struct <id> <initargs> : <ifacet>
                   extends <id> <initargs> : <ifacet> <impls> <mixbody>
             | final struct <id> <initargs> : <ifacet>
                   extends <id> <initargs> : <ifacet> <impls> <mixbody>

<class>    ::= class <id> <initargs> : <ifacet> <impls> <clsbody>
             | final class <initargs> <id> : <ifacet> <impls> <clsbody>
             | class <id> = <id> ( <id> ) ;
             | class <id> <initargs> : <ifacet> 
                  extends <id> <initargs> : <ifacet> <impls> <mixbody>
             | final class <id> <initargs> : <ifacet> 
                  extends <id> <initargs> : <ifacet> <impls> <mixbody>


<mixin>    ::= mixin <id> <initargs> : <ifacet> <initargs> -> <ifacet>
                  <impls> <mixbody>
             | final mixin <id> <initargs> : <ifacet> <initargs> -> <ifacet>
                  <impls> <mixbody>

<initargs> ::= ( <tid> <id> [, <tid> <id>]* )
             | ( )

<impls>    ::= implements <ifacet> [, <ifacet>]*
             | impl <ifacet> [, <ifacet>]*
             |

<clsbody>  ::= { <mfidefn>* <export>* }

<mixbody>  ::= { <mfidefn>* <supernew> <mfidefn>* <export>* }

<mfidefn>  ::= init <tid> <id> ;
             | init <tid> <id> = <expr> ;
             | <tid> <id> = <expr> ;
             | <tid> <id> ( <argdefns> ) <block>

<supernew> ::= super( <newargs> ) ;

<argdefns> ::= <argdefn> [, <argdefn>]* 
             |

<argdefn>  ::= <tid> <id>

<newargs>  ::= <newarg> [, <newarg>]*
             |

<newarg>   ::= <id> = <expr>

<export>   ::= export <ifacet> : <renames> ;

<renames>  ::= <rename> [, <rename>]*

<rename>   ::= <id>
             | <id> as <id>

<expr>     ::= <literal>
             | <lambda>
             | <tuple>
             | #n <expr>
             | <id>
             | <expr> = <expr>
             | <expr> <tuple>
             | this
             | <expr> : <ifacet>
             | <expr> isa <ifacet>
             | if <expr> <block> [else <block>]?
             | cond { [<expr> => <expr> ;]+ }
             | cond { [<expr> => <expr> ;]* else <block> }
             | while <expr> <block>
             | new <id> : <ifacet> ( <newargs> )
             | new <id> ( <newargs> )
             | ! <expr>
             | - <expr>
             | <expr> || <expr>
             | <expr> && <expr>
             | <expr> == <expr>
             | <expr> != <expr>
             | <expr> ==== <expr>
             | <expr> < <expr>
             | <expr> > <expr>
             | <expr> <= <expr>
             | <expr> >= <expr>
             | <expr> + <expr>
             | <expr> - <expr>
             | <expr> * <expr>
             | <expr> / <expr>
             | <expr> % <expr>
             | <expr> . <id>
             | return <expr>
             | <block>

NOTE: Here's the precedence and associativity of things above.
      Top is most strongly binding, bottom is least.  Things on
      the same line have same precedence.  The : below refers to
      casting, and the = is for assignment.  else requires a
      precedence to avoid shift/reduce errors, even though we
      don't have the dangling else problem.

   LEFT   |   RIGHT  |  NONASSOC
----------+----------+-----------
    .     |          |
          |          |    (        (function application)
          |          |   #n        (tuple selector)
          |  :  isa  |
          |          | !, - (un)
   * / %  |          |
   +  -   |          |
          |          | < <= > >=
          |          |   ====
  ==  !=  |          |
    &&    |          |
    ||    |          |
    =     |          |
   else   |          |
          |          |  return

<tuple>    ::= ( )
             | ( <exprs-cd> )
<lambda>   ::= <tid> fun ( <argdecls> ) <block>

<exprs-cd> ::= <expr> [, <expr>]*
             | <expr>

<literal>  ::= <intlit>
             | <floatlit>
             | true
             | false
             | <strlit>
             | <charlit>
             | null

<block>    ::= { <stmts> }

<stmts>    ::= <expr-sc>
             | <vardefn> <stmts>
             | <expr-sc> <stmts>

<vardefn>  ::= <bind> = <expr> ;
             | ( <bind> [, <bind>]* ) = <expr> ;

<expr-sc>  ::= <expr> ;
