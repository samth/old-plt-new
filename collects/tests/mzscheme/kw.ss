
(load-relative "loadtest.ss")

(SECTION 'kw)

(require (lib "kw.ss"))

(let ([t test])

  ;; make sure that lambda/kw behaves as lambda
  (t 1 (lambda/kw () 1))
  (t 1 (lambda/kw (x) 1) 0)
  (t '() (lambda/kw x x))
  (t '(1 2) (lambda/kw x x) 1 2)
  (t '(1 2) (lambda/kw (x . xs) xs) 0 1 2)
  ;; even with keywords
  (t #:x (lambda/kw () #:x))
  (t #:x (lambda/kw (x) #:x) #:y)
  (t '(#:x #:y) (lambda/kw x x) #:x #:y)
  (t '(#:x #:y) (lambda/kw (x . xs) xs) #:z #:x #:y)

  ;; just using #:rest is the same as a dot
  (let ([f (lambda/kw (#:rest r) r)])
    (t '()    f)
    (t '(1)   f 1)
    (t '(1 2) f 1 2))
  (let ([f (lambda/kw (x #:rest r) r)])
    (t '()    f 0)
    (t '(1)   f 0 1)
    (t '(1 2) f 0 1 2))

  ;; using only optionals
  (t 0        procedure-arity (lambda/kw (#:optional) 0))
  (t '(3 1 2) procedure-arity (lambda/kw (x #:optional y z) 0))
  (let ([f (lambda/kw (x #:optional y) (list x y))])
    (t '(0 #f) f 0)
    (t '(0 1)  f 0 1))
  (let ([f (lambda/kw (x #:optional [y 0]) (list x y))])
    (t '(0 0)   f 0)
    (t '(0 1)   f 0 1))
  (let ([f (lambda/kw (x #:optional [y x]) (list x y))])
    (t '(0 0)   f 0)
    (t '(0 1)   f 0 1))
  (let ([f (lambda/kw (x #:optional [y x] [z x]) (list x y z))])
    (t '(0 0 0) f 0)
    (t '(0 1 0) f 0 1)
    (t '(0 1 2) f 0 1 2))
  (let ([f (lambda/kw (x #:optional [y x] [z y]) (list x y z))])
    (t '(0 0 0) f 0)
    (t '(0 1 1) f 0 1)
    (t '(0 1 2) f 0 1 2))

  ;; keywords: default-expr scope
  (let ([f (lambda/kw (#:key x y) (list x y))])
    (t '(#f #f) f)
    (t '(1  #f) f #:x 1)
    (t '(#f 2 ) f #:y 2)
    (t '(1  2 ) f #:x 1 #:y 2)
    (t '(1  2 ) f #:x 1 #:y 2 #:y 3 #:x 4))
  (let ([f (lambda/kw (#:key x [y x]) (list x y))])
    (t '(1  1 ) f #:x 1)
    (t '(#f 2 ) f #:y 2)
    (t '(1  2 ) f #:x 1 #:y 2))
  (let ([f (lambda/kw (#:key x [y x] [z x]) (list x y z))])
    (t '(1  1  1 ) f #:x 1)
    (t '(#f 1  #f) f #:y 1)
    (t '(#f #f 1 ) f #:z 1))
  (let ([f (lambda/kw (#:key x [y x] [z y]) (list x y z))])
    (t '(1  1  1 ) f #:x 1)
    (t '(#f 1  1 ) f #:y 1)
    (t '(#f #f 1 ) f #:z 1))
  (t '(1 2) (let ([y 1]) (lambda/kw (#:key [x y] [y (add1 x)]) (list x y))))
  (t '(1 2) (let ([x 1]) (lambda/kw (#:key [x x] [y (add1 x)]) (list x y))))
  ;; keywords: default-expr evaluation
  (t 1   (lambda/kw (#:key [x 1]) x))
  (t "1" (lambda/kw (#:key [x "1"]) x))
  (t 1   (lambda/kw (#:key [x '1]) x))
  (t ''1 (lambda/kw (#:key [x ''1]) x))
  (t '(add1 1) (lambda/kw (#:key [x '(add1 1)]) x))
  (t + (lambda/kw (#:key [x +]) x))
  (let ([f (lambda ()
             (let ([y 1]) (lambda/kw (#:key [x (begin (set! y 3) 2)]) y)))])
    (t 3 (f))
    (t 1 (f) #:x 1))
  (let ([f (lambda ()
             (let ([y 1])
               (let-syntax ([z (syntax-id-rules () [_ (begin (set! y 3) 2)])])
                 (lambda/kw (#:key [x z]) y))))])
    (t 3 (f))
    (t 1 (f) #:x 1))

  ;; exotic extras
  (let ([f (lambda/kw (#:key a b #:rest r) r)])
    (t '(1 2 3) f 1 2 3)
    (t '(#:a 1 1 2 3) f #:a 1 1 2 3)
    (t '(#:a 1 #:a 2 1 2 3) f #:a 1 #:a 2 1 2 3)
    (t '(#:b 2 1 2 3) f #:b 2 1 2 3)
    (t '(#:a 1 #:b 2 1 2 3) f #:a 1 #:b 2 1 2 3)
    (t '(#:a 1 #:b 2 #:c 3 1 2 3) f #:a 1 #:b 2 #:c 3 1 2 3))
  (let ([f (lambda/kw (#:key a b #:body r) r)])
    (t '(1 2 3) f 1 2 3)
    (t '(1 2 3) f #:a 1 1 2 3)
    (t '(1 2 3) f #:a 1 #:a 2 1 2 3)
    (t '(1 2 3) f #:b 2 1 2 3)
    (t '(1 2 3) f #:a 1 #:b 2 1 2 3))
  (let ([f (lambda/kw (#:key a b #:other-keys r) r)])
    (t '()                   f)
    (t '()                   f #:a 1 #:b 2)
    (t '()                   f #:a 1 #:a 2 #:b 3)
    (t '(#:c 3)              f #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:c 3)        f #:d 4 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:c 3 #:c 33) f #:d 4 #:a 1 #:b 2 #:c 3 #:c 33)
    (t '(#:d 4 #:c 3 #:c 33) f #:d 4 #:a 1 #:c 3 #:b 2 #:c 33))
  (let ([f (lambda/kw (#:key a b #:rest-keys r) r)])
    (t '()                       f)
    (t '(1 2)                    f 1 2)
    (t '()                       f #:a 1 #:b 2)
    (t '(1 2)                    f #:a 1 #:b 2 1 2)
    (t '()                       f #:a 1 #:a 2 #:b 3)
    (t '(1 2)                    f #:a 1 #:a 2 #:b 3 1 2)
    (t '(#:c 3)                  f #:a 1 #:b 2 #:c 3)
    (t '(#:c 3 1 2)              f #:a 1 #:b 2 #:c 3 1 2)
    (t '(#:d 4 #:c 3)            f #:d 4 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:c 3 1 2)        f #:d 4 #:a 1 #:b 2 #:c 3 1 2)
    (t '(#:d 4 #:c 3 #:c 33)     f #:d 4 #:a 1 #:b 2 #:c 3 #:c 33)
    (t '(#:d 4 #:c 3 #:c 33 1 2) f #:d 4 #:a 1 #:b 2 #:c 3 #:c 33 1 2)
    (t '(#:d 4 #:c 3 #:c 33)     f #:d 4 #:a 1 #:c 3 #:b 2 #:c 33)
    (t '(#:d 4 #:c 3 #:c 33 1 2) f #:d 4 #:a 1 #:c 3 #:b 2 #:c 33 1 2)
    )
  (let ([f (lambda/kw (x #:key a b #:all-keys r) r)])
    (t '()                               f 1)
    (t '(#:a 1 #:b 2)                    f 1 #:a 1 #:b 2)
    (t '(#:a 1 #:a 2 #:b 3)              f 1 #:a 1 #:a 2 #:b 3)
    (t '(#:a 1 #:b 2 #:c 3)              f 1 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:a 1 #:b 2 #:c 3)        f 1 #:d 4 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:a 1 #:b 2 #:c 3 #:c 33) f 1 #:d 4 #:a 1 #:b 2 #:c 3 #:c 33)
    (t '(#:d 4 #:a 1 #:c 3 #:b 2 #:c 33) f 1 #:d 4 #:a 1 #:c 3 #:b 2 #:c 33)
    (err/rt-test (f 1 #:a 2 3))
    (err/rt-test (f 1 #:a 2 3 4))
    )
  ;; check when other keys are allowed
  (err/rt-test ((lambda/kw (#:key a #:body r) r) #:a 1 #:b 2))
  (err/rt-test ((lambda/kw (#:key a) a) #:a 1 #:b 2))
  (t 1 (lambda/kw (#:key a #:rest r) a) #:a 1 #:b 2)
  (t 1 (lambda/kw (#:key a #:rest-keys r) a) #:a 1 #:b 2)
  (t 1 (lambda/kw (#:key a #:allow-other-keys) a) #:a 1 #:b 2)
  (err/rt-test ((lambda/kw (#:key a #:rest r #:forbid-other-keys) a) #:a 1 #:b 2))
  ;; check when body is allowed
  (err/rt-test ((lambda/kw (#:key a #:all-keys r) r) #:a 1 #:b 2 3))
  (err/rt-test ((lambda/kw (#:key a #:all-keys r) r) #:a 1 #:b 2 3 4))
  (err/rt-test ((lambda/kw (#:key a #:other-keys r) r) #:a 1 #:b 2 3))
  (err/rt-test ((lambda/kw (#:key a #:other-keys r) r) #:a 1 #:b 2 3 4))
  (t '(#:a 1 #:b 2 3)   (lambda/kw (#:key a #:rest r) r) #:a 1 #:b 2 3)
  (t '(#:a 1 #:b 2 3 4) (lambda/kw (#:key a #:rest r) r) #:a 1 #:b 2 3 4)
  (t '(3)   (lambda/kw (#:key a #:body r) r) #:a 1 3)
  (t '(3 4) (lambda/kw (#:key a #:body r) r) #:a 1 3 4)
  (t '(3)   (lambda/kw (#:key a #:body r) r) #:a 1 #:a 2 3)
  (t '(3 4) (lambda/kw (#:key a #:body r) r) #:a 1 #:a 2 3 4)
  (err/rt-test ((lambda/kw (#:key a #:body r #:forbid-body) r) #:a 1 3))
  (t '(#:a 1 #:b 2) (lambda/kw (#:key a #:all-keys r #:allow-body) r) #:a 1 #:b 2 3)

  )

;; test syntax errors
(let ([st syntax-test])
  (st #'(lambda/kw (x #:blah y) 1))
  (st #'(lambda/kw (x #:rest) 1))
  (st #'(lambda/kw (x #:key k #:key o) 1))
  (st #'(lambda/kw (x #:key k #:optional o) 1))
  (st #'(lambda/kw (x #:optional k #:optional o) 1))
  (st #'(lambda/kw (x #:rest r #:optional o) 1))
  (st #'(lambda/kw (x #:rest r #:forbid-other-keys #:allow-other-keys) 1))
  (st #'(lambda/kw (x #:rest r #:allow-other-keys #:forbid-other-keys) 1))
  (st #'(lambda/kw (x #:rest r1 #:rest r2) 1))
  (st #'(lambda/kw (x #:rest) 1))
  (st #'(lambda/kw (x #:rest r1 r2) 1))
  (st #'(lambda/kw (x #:body b) 1))
  (st #'(lambda/kw (x x) 1))
  (st #'(lambda/kw (x #:optional [x 1]) 1))
  (st #'(lambda/kw (x #:key [x 1]) 1))
  (st #'(lambda/kw (x #:rest x) 1))
  (st #'(lambda/kw (x #:body x) 1))
  (st #'(lambda/kw (x #:optional 3) 1))
  (st #'(lambda/kw (x #:optional "3") 1))
  (st #'(lambda/kw (x #:optional [(x) 3]) 1))
  (st #'(lambda/kw (x #:key 3) 1))
  (st #'(lambda/kw (x #:key "3") 1))
  (st #'(lambda/kw (x #:key [(x) 3]) 1))
  (st #'(lambda/kw (x #:rest 3) 1))
  (st #'(lambda/kw (x #:rest "3") 1))
  (st #'(lambda/kw (x #:rest (x)) 1))
  (st #'(lambda/kw (x #:body 3) 1))
  (st #'(lambda/kw (x #:body "3") 1))
  (st #'(lambda/kw (x #:body (x)) 1))
  (st #'(lambda/kw (x #:body x #:allow-other-keys) 1))
  (st #'(lambda/kw (x #:optional ()) 1))
  (st #'(lambda/kw (x #:optional (x y z)) 1)))
