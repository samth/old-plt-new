
(load-relative "loadtest.ss")

(SECTION 'kw)

(require (lib "kw.ss"))

(let ([t test])

  ;; make sure that lambda/kw behaves as lambda
  (t 1 (lambda/kw () 1))
  (t 1 (lambda/kw (x) 1) 0)
  (t '() (lambda/kw x x))
  (t '(1 2) (lambda/kw x x) 1 2)
  (t '(1 2) (lambda/kw (x . xs) xs) 0 1 2)
  ;; even with keywords
  (t #:x (lambda/kw () #:x))
  (t #:x (lambda/kw (x) #:x) #:y)
  (t '(#:x #:y) (lambda/kw x x) #:x #:y)
  (t '(#:x #:y) (lambda/kw (x . xs) xs) #:z #:x #:y)

  ;; just using #:rest is the same as a dot
  (let ([f (lambda/kw (#:rest r) r)])
    (t '()    f)
    (t '(1)   f 1)
    (t '(1 2) f 1 2))
  (let ([f (lambda/kw (x #:rest r) r)])
    (t '()    f 0)
    (t '(1)   f 0 1)
    (t '(1 2) f 0 1 2))

  ;; using only optionals
  (t 0        procedure-arity (lambda/kw (#:optional) 0))
  (t '(3 1 2) procedure-arity (lambda/kw (x #:optional y z) 0))
  (let ([f (lambda/kw (x #:optional y) (list x y))])
    (t '(0 #f) f 0)
    (t '(0 1)  f 0 1))
  (let ([f (lambda/kw (x #:optional [y 0]) (list x y))])
    (t '(0 0)   f 0)
    (t '(0 1)   f 0 1))
  (let ([f (lambda/kw (x #:optional [y x]) (list x y))])
    (t '(0 0)   f 0)
    (t '(0 1)   f 0 1))
  (let ([f (lambda/kw (x #:optional [y x] [z x]) (list x y z))])
    (t '(0 0 0) f 0)
    (t '(0 1 0) f 0 1)
    (t '(0 1 2) f 0 1 2))
  (let ([f (lambda/kw (x #:optional [y x] [z y]) (list x y z))])
    (t '(0 0 0) f 0)
    (t '(0 1 1) f 0 1)
    (t '(0 1 2) f 0 1 2))

  ;; keywords: basic stuff
  (let ([f (lambda/kw (#:key x [y 1] [z #:zz #:z]) (list x y z))])
    (t '(#f 1 #:z)     f)
    (t '(#:zz 1 #:zzz) f #:zz #:zzz #:zz 123 #:x #:zz))
  ;; keywords: default-expr scope
  (let ([f (lambda/kw (#:key x y) (list x y))])
    (t '(#f #f) f)
    (t '(1  #f) f #:x 1)
    (t '(#f 2 ) f #:y 2)
    (t '(1  2 ) f #:x 1 #:y 2)
    (t '(1  2 ) f #:x 1 #:y 2 #:y 3 #:x 4))
  (let ([f (lambda/kw (#:key x [y x]) (list x y))])
    (t '(1  1 ) f #:x 1)
    (t '(#f 2 ) f #:y 2)
    (t '(1  2 ) f #:x 1 #:y 2))
  (let ([f (lambda/kw (#:key x [y x] [z x]) (list x y z))])
    (t '(1  1  1 ) f #:x 1)
    (t '(#f 1  #f) f #:y 1)
    (t '(#f #f 1 ) f #:z 1))
  (let ([f (lambda/kw (#:key x [y x] [z y]) (list x y z))])
    (t '(1  1  1 ) f #:x 1)
    (t '(#f 1  1 ) f #:y 1)
    (t '(#f #f 1 ) f #:z 1))
  (t '(1 2) (let ([y 1]) (lambda/kw (#:key [x y] [y (add1 x)]) (list x y))))
  (t '(1 2) (let ([x 1]) (lambda/kw (#:key [x x] [y (add1 x)]) (list x y))))
  ;; keywords: default-expr evaluation
  (t 1   (lambda/kw (#:key [x 1]) x))
  (t "1" (lambda/kw (#:key [x "1"]) x))
  (t 1   (lambda/kw (#:key [x '1]) x))
  (t ''1 (lambda/kw (#:key [x ''1]) x))
  (t '(add1 1) (lambda/kw (#:key [x '(add1 1)]) x))
  (t + (lambda/kw (#:key [x +]) x))
  (let ([f (lambda ()
             (let ([y 1]) (lambda/kw (#:key [x (begin (set! y 3) 2)]) y)))])
    (t 3 (f))
    (t 1 (f) #:x 1))
  (let ([f (lambda ()
             (let ([y 1])
               (let-syntax ([z (syntax-id-rules () [_ (begin (set! y 3) 2)])])
                 (lambda/kw (#:key [x z]) y))))])
    (t 3 (f))
    (t 1 (f) #:x 1))
  ;; keywords: make sure that getarg stops at end of keyword part
  (let ([f (lambda/kw (#:key x y #:body b) (list x y b))])
    (t '(#f #f (2 #:x 1)) f 2 #:x 1)
    (t '(#f #f (2 3 #:x 1)) f 2 3 #:x 1))

  ;; exotic extras
  (let ([f (lambda/kw (#:key a b #:rest r) r)])
    (t '(1 2 3) f 1 2 3)
    (t '(#:a 1 1 2 3) f #:a 1 1 2 3)
    (t '(#:a 1 #:a 2 1 2 3) f #:a 1 #:a 2 1 2 3)
    (t '(#:b 2 1 2 3) f #:b 2 1 2 3)
    (t '(#:a 1 #:b 2 1 2 3) f #:a 1 #:b 2 1 2 3)
    (t '(#:a 1 #:b 2 #:c 3 1 2 3) f #:a 1 #:b 2 #:c 3 1 2 3))
  (let ([f (lambda/kw (#:key a b #:body r) r)])
    (t '(1 2 3) f 1 2 3)
    (t '(1 2 3) f #:a 1 1 2 3)
    (t '(1 2 3) f #:a 1 #:a 2 1 2 3)
    (t '(1 2 3) f #:b 2 1 2 3)
    (t '(1 2 3) f #:a 1 #:b 2 1 2 3))
  (let ([f (lambda/kw (#:key a b #:other-keys r) r)])
    (t '()                   f)
    (t '()                   f #:a 1 #:b 2)
    (t '()                   f #:a 1 #:a 2 #:b 3)
    (t '(#:c 3)              f #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:c 3)        f #:d 4 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:c 3 #:c 33) f #:d 4 #:a 1 #:b 2 #:c 3 #:c 33)
    (t '(#:d 4 #:c 3 #:c 33) f #:d 4 #:a 1 #:c 3 #:b 2 #:c 33))
  (let ([f (lambda/kw (#:key a b #:rest-keys r) r)])
    (t '()                       f)
    (t '(1 2)                    f 1 2)
    (t '()                       f #:a 1 #:b 2)
    (t '(1 2)                    f #:a 1 #:b 2 1 2)
    (t '()                       f #:a 1 #:a 2 #:b 3)
    (t '(1 2)                    f #:a 1 #:a 2 #:b 3 1 2)
    (t '(#:c 3)                  f #:a 1 #:b 2 #:c 3)
    (t '(#:c 3 1 2)              f #:a 1 #:b 2 #:c 3 1 2)
    (t '(#:d 4 #:c 3)            f #:d 4 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:c 3 1 2)        f #:d 4 #:a 1 #:b 2 #:c 3 1 2)
    (t '(#:d 4 #:c 3 #:c 33)     f #:d 4 #:a 1 #:b 2 #:c 3 #:c 33)
    (t '(#:d 4 #:c 3 #:c 33 1 2) f #:d 4 #:a 1 #:b 2 #:c 3 #:c 33 1 2)
    (t '(#:d 4 #:c 3 #:c 33)     f #:d 4 #:a 1 #:c 3 #:b 2 #:c 33)
    (t '(#:d 4 #:c 3 #:c 33 1 2) f #:d 4 #:a 1 #:c 3 #:b 2 #:c 33 1 2)
    )
  (let ([f (lambda/kw (x #:key a b #:all-keys r) r)])
    (t '()                               f 1)
    (t '(#:a 1 #:b 2)                    f 1 #:a 1 #:b 2)
    (t '(#:a 1 #:a 2 #:b 3)              f 1 #:a 1 #:a 2 #:b 3)
    (t '(#:a 1 #:b 2 #:c 3)              f 1 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:a 1 #:b 2 #:c 3)        f 1 #:d 4 #:a 1 #:b 2 #:c 3)
    (t '(#:d 4 #:a 1 #:b 2 #:c 3 #:c 33) f 1 #:d 4 #:a 1 #:b 2 #:c 3 #:c 33)
    (t '(#:d 4 #:a 1 #:c 3 #:b 2 #:c 33) f 1 #:d 4 #:a 1 #:c 3 #:b 2 #:c 33)
    (err/rt-test (f 1 #:a 2 3))
    (err/rt-test (f 1 #:a 2 3 4))
    )
  ;; check when other keys are allowed
  (err/rt-test ((lambda/kw (#:key a #:body r) r) #:a 1 #:b 2))
  (err/rt-test ((lambda/kw (#:key a) a) #:a 1 #:b 2))
  (t 1 (lambda/kw (#:key a #:rest r) a) #:a 1 #:b 2)
  (t 1 (lambda/kw (#:key a #:rest-keys r) a) #:a 1 #:b 2)
  (t 1 (lambda/kw (#:key a #:allow-other-keys) a) #:a 1 #:b 2)
  (err/rt-test ((lambda/kw (#:key a #:rest r #:forbid-other-keys) a) #:a 1 #:b 2))
  ;; check when body is allowed
  (err/rt-test ((lambda/kw (#:key a #:all-keys r) r) #:a 1 #:b 2 3))
  (err/rt-test ((lambda/kw (#:key a #:all-keys r) r) #:a 1 #:b 2 3 4))
  (err/rt-test ((lambda/kw (#:key a #:other-keys r) r) #:a 1 #:b 2 3))
  (err/rt-test ((lambda/kw (#:key a #:other-keys r) r) #:a 1 #:b 2 3 4))
  (t '(#:a 1 #:b 2 3)   (lambda/kw (#:key a #:rest r) r) #:a 1 #:b 2 3)
  (t '(#:a 1 #:b 2 3 4) (lambda/kw (#:key a #:rest r) r) #:a 1 #:b 2 3 4)
  (t '(3)   (lambda/kw (#:key a #:body r) r) #:a 1 3)
  (t '(3 4) (lambda/kw (#:key a #:body r) r) #:a 1 3 4)
  (t '(3)   (lambda/kw (#:key a #:body r) r) #:a 1 #:a 2 3)
  (t '(3 4) (lambda/kw (#:key a #:body r) r) #:a 1 #:a 2 3 4)
  (err/rt-test ((lambda/kw (#:key a #:body r #:forbid-body) r) #:a 1 3))
  (t '(#:a 1 #:b 2) (lambda/kw (#:key a #:all-keys r #:allow-body) r) #:a 1 #:b 2 3)
  (err/rt-test ((lambda/kw (#:key x y) (list x y)) #:x))
  (err/rt-test ((lambda/kw (#:key x y) (list x y)) #:x 1 #:x))
  (err/rt-test ((lambda/kw (#:key x y) (list x y)) #:x #:x #:x))

  ;; optionals and keys
  (let ([f (lambda/kw (#:optional a b #:key c d) (list a b c d))])
    (t '(#f #f #f #f)    f)
    (t '(1 #f #f #f)     f 1)
    (t '(1 2 #f #f)      f 1 2)
    (t '(#:c #:d #f #f)  f #:c #:d)
    (t '(#:c 1 #f #f)    f #:c 1)
    (t '(1 2 #:d #f)     f 1 2 #:c #:d)
    (t '(#:c #:d #:d #f) f #:c #:d #:c #:d)
    (t '(#:c 1 #:d #f)   f #:c 1 #:c #:d))

  ;; multi-level arg lists with #:body specs
  (let ([f (lambda/kw (#:key x y #:body (z)) (list x y z))])
    (t '(#f #f 3) f 3)
    (t '(#f 2 3)  f #:y 2 3)
    (err/rt-test (f #:y 2))
    (err/rt-test (f #:y 2 3 4)))
  (let ([f (lambda/kw (#:key x y #:body (z . r)) (list x y z r))])
    (t '(#f #f 3 ()) f 3)
    (t '(#f 2 3 ())  f #:y 2 3)
    (err/rt-test (f #:y 2))
    (t '(#f 2 3 (4)) f #:y 2 3 4))
  (let ([f (lambda/kw (#:key x y #:body (a #:key (xx #:x #f) (yy #:y #f)))
             (list x y a xx yy))])
    (t '(1 #f 2 3 #f)   f #:x 1 2 #:x 3)
    (t '(1 #:x 2 3 #:x) f #:x 1 #:y #:x #:x 11 2 #:x 3 #:y #:x #:x 33))

  )

;; test syntax errors
(let ([st syntax-test])
  (st #'(lambda/kw (x #:blah y) 1))
  (st #'(lambda/kw (x #:rest) 1))
  (st #'(lambda/kw (x #:key k #:key o) 1))
  (st #'(lambda/kw (x #:key k #:optional o) 1))
  (st #'(lambda/kw (x #:optional k #:optional o) 1))
  (st #'(lambda/kw (x #:rest r #:optional o) 1))
  (st #'(lambda/kw (x #:rest r #:forbid-other-keys #:allow-other-keys) 1))
  (st #'(lambda/kw (x #:rest r #:allow-other-keys #:forbid-other-keys) 1))
  (st #'(lambda/kw (x #:rest r1 #:rest r2) 1))
  (st #'(lambda/kw (x #:rest) 1))
  (st #'(lambda/kw (x #:rest r1 r2) 1))
  (st #'(lambda/kw (x #:body b) 1))
  (st #'(lambda/kw (x x) 1))
  (st #'(lambda/kw (x #:optional [x 1]) 1))
  (st #'(lambda/kw (x #:key [x 1]) 1))
  (st #'(lambda/kw (x #:rest x) 1))
  (st #'(lambda/kw (x #:body x) 1))
  (st #'(lambda/kw (x #:optional 3) 1))
  (st #'(lambda/kw (x #:optional "3") 1))
  (st #'(lambda/kw (x #:optional [(x) 3]) 1))
  (st #'(lambda/kw (x #:key 3) 1))
  (st #'(lambda/kw (x #:key "3") 1))
  (st #'(lambda/kw (x #:key [(y) 3]) 1))
  (st #'(lambda/kw (x #:key [x]) 1))
  (st #'(lambda/kw (x #:key [y 1 2]) 1))
  (st #'(lambda/kw (x #:key [y #:y 1 2]) 1))
  (st #'(lambda/kw (x #:rest 3) 1))
  (st #'(lambda/kw (x #:rest "3") 1))
  (st #'(lambda/kw (x #:rest (x)) 1))
  (st #'(lambda/kw (x #:body 3) 1))
  (st #'(lambda/kw (x #:key y #:body 3) 1))
  (st #'(lambda/kw (x #:body "3") 1))
  (st #'(lambda/kw (x #:key y #:body "3") 1))
  (st #'(lambda/kw (x #:body (x)) 1))
  (st #'(lambda/kw (x #:body x #:allow-other-keys) 1))
  (st #'(lambda/kw (x #:optional ()) 1))
  (st #'(lambda/kw (x #:optional (x y z)) 1))
  (st #'(lambda/kw (x #:other-keys z) 1))
  (st #'(lambda/kw (x #:rest-keys z) 1))
  (st #'(lambda/kw (x #:all-keys z) 1))
  (st #'(lambda/kw (x #:key y #:allow-other-keys z) 1))
  (st #'(lambda/kw (x #:key y #:forbid-body z) 1))
  (st #'(lambda/kw (x #:key y #:allow-body #:rest r #:forbid-body) 1))
  (st #'(lambda/kw (x #:key y #:forbid-other-keys #:rest r #:allow-other-keys) 1))
  (st #'((lambda/kw (x #:key y z #:body (x)) x) 1)))
