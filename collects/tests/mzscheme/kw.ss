
(load-relative "loadtest.ss")

(SECTION 'kw)

(require (lib "kw.ss"))

(let ([t test])
  ;; make sure that lambda/kw behaves as lambda
  (t 1 (lambda/kw () 1))
  (t 1 (lambda/kw (x) 1) 0)
  (t '() (lambda/kw x x))
  (t '(1 2) (lambda/kw x x) 1 2)
  (t '(1 2) (lambda/kw (x . xs) xs) 0 1 2)
  ;; even with keywords
  (t #:x (lambda/kw () #:x))
  (t #:x (lambda/kw (x) #:x) #:y)
  (t '(#:x #:y) (lambda/kw x x) #:x #:y)
  (t '(#:x #:y) (lambda/kw (x . xs) xs) #:z #:x #:y)

  ;; just using #:rest is the same as a dot
  (let ([f (lambda/kw (#:rest r) r)])
    (t '()    f)
    (t '(1)   f 1)
    (t '(1 2) f 1 2))
  (let ([f (lambda/kw (x #:rest r) r)])
    (t '()    f 0)
    (t '(1)   f 0 1)
    (t '(1 2) f 0 1 2))

  ;; using only optionals
  (t 0 procedure-arity (lambda/kw (#:optional) 0))
  (t '(0 #f)  (lambda/kw (x #:optional y) (list x y)) 0)
  (t '(0 1)   (lambda/kw (x #:optional y) (list x y)) 0 1)
  (t '(0 0)   (lambda/kw (x #:optional [y 0]) (list x y)) 0)
  (t '(0 1)   (lambda/kw (x #:optional [y 0]) (list x y)) 0 1)
  (t '(0 0)   (lambda/kw (x #:optional [y x]) (list x y)) 0)
  (t '(0 1)   (lambda/kw (x #:optional [y x]) (list x y)) 0 1)
  (t '(0 0 0) (lambda/kw (x #:optional [y x] [z x]) (list x y z)) 0)
  (t '(0 1 0) (lambda/kw (x #:optional [y x] [z x]) (list x y z)) 0 1)
  (t '(0 1 2) (lambda/kw (x #:optional [y x] [z x]) (list x y z)) 0 1 2)
  (t '(0 0 0) (lambda/kw (x #:optional [y x] [z y]) (list x y z)) 0)
  (t '(0 1 1) (lambda/kw (x #:optional [y x] [z y]) (list x y z)) 0 1)
  (t '(0 1 2) (lambda/kw (x #:optional [y x] [z y]) (list x y z)) 0 1 2)
  )

;; test syntax errors
(let ([st syntax-test])
  (st #'(lambda/kw (x #:blah y) 1))
  (st #'(lambda/kw (x #:rest) 1))
  (st #'(lambda/kw (x #:key k #:key o) 1))
  (st #'(lambda/kw (x #:key k #:optional o) 1))
  (st #'(lambda/kw (x #:optional k #:optional o) 1))
  (st #'(lambda/kw (x #:rest r #:optional o) 1))
  (st #'(lambda/kw (x #:rest r #:forbid-other-keys #:allow-other-keys) 1))
  (st #'(lambda/kw (x #:rest r #:allow-other-keys #:forbid-other-keys) 1))
  (st #'(lambda/kw (x #:rest r1 #:rest r2) 1))
  (st #'(lambda/kw (x #:rest) 1))
  (st #'(lambda/kw (x #:rest r1 r2) 1))
  (st #'(lambda/kw (x #:body b) 1))
  (st #'(lambda/kw (x x) 1))
  (st #'(lambda/kw (x #:optional [x 1]) 1))
  (st #'(lambda/kw (x #:key [x 1]) 1))
  (st #'(lambda/kw (x #:rest x) 1))
  (st #'(lambda/kw (x #:body x) 1))
  (st #'(lambda/kw (x #:optional 3) 1))
  (st #'(lambda/kw (x #:optional "3") 1))
  (st #'(lambda/kw (x #:optional [(x) 3]) 1))
  (st #'(lambda/kw (x #:key 3) 1))
  (st #'(lambda/kw (x #:key "3") 1))
  (st #'(lambda/kw (x #:key [(x) 3]) 1))
  (st #'(lambda/kw (x #:rest 3) 1))
  (st #'(lambda/kw (x #:rest "3") 1))
  (st #'(lambda/kw (x #:rest (x)) 1))
  (st #'(lambda/kw (x #:body 3) 1))
  (st #'(lambda/kw (x #:body "3") 1))
  (st #'(lambda/kw (x #:body (x)) 1))
  (st #'(lambda/kw (x #:body x #:allow-other-keys) 1))
  (st #'(lambda/kw (x #:optional ()) 1))
  (st #'(lambda/kw (x #:optional (x y z)) 1)))
