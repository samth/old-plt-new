

============================================================

  About MzTake

_MzTake_ is a _scripted debugger_ for PLT Scheme. It helps
programmers monitor the execution of a target program as it
unfolds (and optionally pause or resume its execution!).
In the future, MzTake will support other kinds of interactions,
such as inspecting the call stack.

MzTake scripts are written in the FrTime programming
language, which is bundled with DrScheme. FrTime supports the
implementation of reactive systems in a functional style.
The key abstraction it adds is a type of value called a 'signal',
which can change over time. FrTime infers dataflow dependencies
between signals and automatically recomputes them when necessary.

With signals (implemented as "event streams" and "behaviors"),
it is possible to respond to outside events concisely (without
using callbacks). Consider a MzTake script to monitor the
behavior of the program "highway.ss", in the demos directory
of the MzTake collection:

   (debug-mztake-process
     radar-program
     ("highway.ss" [values-of-speed 3 4 bind 'speed]))
   (printf-b "current speed: ~a" (hold values-of-speed))
   (start/resume radar-program)

This code executes a target module in the file "highway.ss"
after installing a _trace point_ (also known as a
_watch point_) just before the Scheme expression on the fourth
column of the third line of "highway.ss". VALUES-OF-SPEED
is a FrTime event stream that always contains the *current*
value (and potentially every past value) of the variable named
SPEED, as it is bound to the values corresponding to that
syntactic location.

PRINTF-B works like Scheme's PRINTF function, consuming a
format-string and fill-values, printing the result in
DrScheme's interaction pane. Whereas PRINTF accumulates
outdated text on the screen, PRINTF-B will replace old text
with updated text if any of the fill-values change. In this
invocation, it prints the current speed to screen, throughout
the execution of "highway.ss".

MzTake scripts are also powerful tools for building external
test suites. Whereas typical test cases may only assert that
the result of a computation is correct, MzTake scripts
can dynamically break open an execution, record inner state,
and *compute* with it. This allows you to confirm that the
intermediate steps which lead to a correct answer were
also correct. In the example below, we use a version of map
that operates over events in an event stream, instead of
elements in a list. We assert that all recorded speeds are
less than 55, otherwise we raise an exception:

  (map-e (lambda (a-speed)
           (when (>= a-speed 55) (raise 'too-fast!!)))
         values-of-speed)

Of course, like most test suites, this only tells you
something went wrong. Perhaps knowing the last ten speeds that
led to this would prove useful. You could PRINTF the value
onto a new line each time, but after ten updates the screen
is already starting to fill up with information -- we are
only interested in the last ten speeds, after all.
One possible solution:

  (printf-b "last ten speeds: ~a" (history-b 10 values-of-speed))
  (map-e (lambda (a-speed)
           (when (>= a-speed 55) (raise 'too-fast!!)))
         values-of-speed)

HISTORY-B consumes a number and an event stream (VALUES-OF-SPEED),
returning a FrTime behavior containing a FIFO ordered list of
the last ten values emitted on that event stream. In this case,
HISTORY-B maintains a list of the ten most recent SPEEDS seen
on VALUES-OF-SPEED (up until the exception is raised). Though
this is is an improvement, we still can't *use* that list as
data to see what led to the exception. One possible solution:

  (define last-ten (history-b 10 values-of-speed))
  (printf-b "last ten speeds: ~a" last-ten)
  (map-e (lambda (a-speed)
                 (when (>= a-speed 55) (pause radar-program)))
         values-of-speed)

MzTake allows you to "pause" a target program anytime during
execution. Once paused, it becomes trivial to interactively
explore and compute with script variables (such as LAST-TEN)
in the interaction pane. Once satisfied, you can easily resume
execution by typing "(start/resume radar-program)", or end it
with "(kill radar-program)".

Finally, FrTime provides a rich animation library. Combined
with the MzTake debugger, it takes only a few lines to animate
your algorithms and see them in action, easily letting you
confirm (or refute!) that they are working correctly.

  (display-shapes (make-speed-gauge (hold values-of-speed)))


============================================================

  Installing MzTake

MzTake is a DrScheme tool distributed as a self-installing
".PLT" file from the PLaneT Package Repository.

  http://planet.plt-scheme.org/


============================================================

  Demos

You can find demos of a few different uses of MzTake (including
the "highway.ss" example) in the following directories:

   On Linux:
   $PLTHOME/collects/mztake/demos/

   On Windows (typically):
   c:\Program Files\PLT\collects\mztake\demos\

You should be able to run them in DrScheme by switching to the
"MzTake" language from the "Experimental Languages" section
of DrScheme's language dialog, and then selecting "Run"
(or "Execute") from the DrScheme tool bar.

  ./highway/highway-test.ss        - a small MzTake example, shown above

  ./sine/sine-test.ss              - plots values extracted from the
                                     running program

  ./montecarlo/montecarlo-test.ss  - visualizes the Monte Carlo
                                     integration used to derive the
                                     value of pi

  ./random/random-Xs-test.ss       - tests the quality of Scheme's random
                                     number generator with a histogram

  ./misc/exception-test.ss         - demonstrates how MzTake catches exceptions

  ./misc/first-class-test.ss       - demonstrates how you can add multiple
                                     traces to the same variable in a file
                                     to 'record' its evolution, and how you
                                     can trace first-class functions, such
                                     as those passed to map.


============================================================

  Functions

The demos demonstrate many ways to debug with MzTake using
FrTime, even if you are not very familiar with the language.
That said, in order to become more proficient in using MzTake,
you will want to learn more about the FrTime language.

You can refer to FrTime's own documentation by searching for
"frtime" in DrScheme's Help window. It explains how to use
time-varying behaviors and event streams in greater depth, and
also describes the many useful functions FrTime provides to work
with them.



============================================================

_Debugging with MzTake_

The model of the debugger is as follows:

  * A single debugging script file contains all the MzTake
    processes, traces, bindings, animations, and other FrTime
    code fragments that do the debugging and program monitoring.

  * This script file is run in the MzTake language in DrScheme.
    Interaction and textual print-outs are provided in the
    interaction pane.

  * A MzTake *process* is like an operating system that runs a group of
    programs, installs hooks into them to monitor their execution,
    and provides FrTime with these hooks to do computations.

  * Each MzTake process is independent of the other MzTake processes.
    One will not affect the other, only their traces can interact in
    the script.

  * A MzTake process accepts a number of target-files as "clients" to
    debug and monitor. Each client should contain a module program,
    of the form:

       (module mod-nam mzscheme
         (... module body ...))

    MzTake does not support debugging anything other than modules.

  * The first client defined for each process is *always* the main module.
    That is, START/RESUME runs the *first* client module (in the same way
    that you run it in DrScheme in the "module..." language), assuming there
    will be side-effects that start the debugging.

    The rest of the files traced in a mztake-process are typically
    modules used *by* the main-module, allowing you to see
    what is going on deeper than the main module. For example:

      (mztake-process p1
            ("my-stack-tests.ss")
            ((lib "my-stack.ss" "my-stack") [s-push-p1 3  29 bind 'insert-value]
                                            [s-pop-p1  10 16 bind 'return-value]))

    "my-stack-tests.ss" uses functions from "my-stack.ss". You want to
     make sure "my-stack.ss" is working properly in the context of
    running the module in "my-stack-tests.ss" for side-effects.

  * The same file can be traced differently in different processes, even with
    different main clients using them:

      (mztake-process p2
            ("more-my-stack-tests.ss")
            ((lib "my-stack.ss" "my-stack") [s-clear-p2 22 8 ENTRY]))

    This installs an ENTRY trace at the function entry point for (clear).
    Every time (clear) gets called, s-clear-p2 will get a ping of "#t".

  * Once all the processes are defined, (start/resume ...) is called on
    each starting their execution.

  * All the variables bound (MZTAKE-PROCESSes, BINDs, ENTRYs),
    from all the different MZTAKE-PROCESSes, are collected together by
    MzTake so they can be all be computed with using FrTime functions
    and idioms.

  * Processes have certain properties and predicates which you can get,
    such as runtime (in seconds or milliseconds), exceptions that are thrown,
    and whether the process exited yet.  See "process:runtime/(milli)seconds",
    "process:exceptions", and "process:exited?".

  * Lastly, proceses can be started, paused, resumed, and terminated.
    See START/RESUME, PAUSE, KILL, KILL-ALL.



============================================================

MzTake itself defines the following functions:

_Installing Trace Points_

Currently, MzTake offers two types of traces: ENTRY and BIND.
ENTRYs are event streams that get a "#t" event every time the
target program reaches the trace point. Binds are event streams that
ping the value of one or more variables when the trace point is reached.

> (mztake-process process-name
    [target-filename trace-clause ...] ...)

   Where trace-clause is one of the following:

    <1>  [trace-name line-number column-number ENTRY]
    <2>  [trace-name line-number column-number bind 'variable-name]
    <3>  [trace-name line-number column-number bind '(variable-name ...)]

   MZTAKE-PROCESS defines the variable process-name,
   whose value is a MzTake process object. That object
   can be passed to functions such as START/RESUME, KILL,
   and "process:runtime/milliseconds", documented in the next
   section.

   MZTAKE-PROCESS installs trace points in one or many files,
   as indicated by the trace-clauses. The target-filename can
   be any file specification accepted by the standard REQUIRE
   syntax for modules:

   * Absolute path:
       (mztake-process p [(file "/home/me/test.ss") [brk 10 7 ENTRY]])

   * Relative path:
       (mztake-process p ["../test.ss" [brk 10 7 ENTRY]])

   * Library path:
       (mztake-process p [(lib "test.ss" "collect-dir") [brk 10 7 ENTRY]])

   For each trace-clause in the call to mztake-process,
   the trace-name is a variable name bound at the
   top-level, whose value is a FrTime event
   stream. Each time the execution of the target
   reaches the given line-number and column[*], the
   debugger emits an event on that stream. The value of
   that event depends on which of the three kinds of
   trace-clause was used, as follows:

      <1> The value of the event is #t (an ENTRY trace).

      <2> The value of the event is the value of variable-name,
          in the target program, at the location of the
          trace point (a BIND trace).

      <3> The value of the event is a list containing one
          element for each variable name given. The value
          of each element is taken from the variable of
          that name in the target (as in <2>).

   Trace points do not themselves pause the
   program. Unless a MzTake process is suspended using
   the PAUSE function (below), execution resumes after
   the MzTake script processed the event.

   [*] Valid locations to add traces to are almost 
       always one character to the left of open-parentheses, "(",
       open-square-braces, "[", or to the left of the first
       character of a symbol/name (LET is a special exception,
       see Known Problems for more information on tracing LET):

         (code [more-code ...] ...)
         ^^    ^^         ^

   [*] To obtain accurate line/column information when
       setting up trace points, make sure you turn off
       DrScheme's "Wrap Text" feature under the "Edit"
       menu. Alternatively, you can position your cursor
       at the location where you want to add a trace,
       and click MzTake's "Syntax Location" button on the
       main DrScheme toolbar. A message-box will tell
       the correct line and column numbers to use.
   

_Operations on MzTake Processes_

The following functions operate on MzTake processes,
and can be used in the Interactions window.

> (start/resume process-name)

   Start the execution and monitoring of the mztake-process,
   process-name. If the process given to START/RESUME is already
   running, and was paused with the function PAUSE (below),
   START/RESUME resumes its execution.

   Script statements are executed top-down, sequentially.
   In general, you want to call start/resume at the end of
   the script, or in the interactions pane after you
   start running the script. Otherwise, a race condition may
   develop, where your script may miss events from the
   beginning of the execution.

> (pause process)

   Suspends the execution of the given mztake
   process. Use START/RESUME to resume execution.

> (kill process)

   Kills the target process and releases all resources
   it used -- you cannot START/RESUME after a KILL.

   Closing a FrTime animation/graphics window will *not*
   kill a running MzTake process. If it does not terminate
   on its own, you may kill it with "(kill p-name)" or
   "(kill-all)" in the Interactions window.

> (kill-all)

   kill-all kills all the processes currently running
   under MzTake -- use this when it seems a process is
   out of control and needs to be stopped immediately.
   Has the same effect of calling KILL on each process
   you defined and START/RESUME'd in the script.

> (process:exceptions process)

   Returns an event stream. If the target process
   throws an uncaught exception, the exception will
   appear on this stream.

> (process:runtime/seconds process)

   Returns a FrTime time-varying value which counts the
   number of seconds elapsed in the execution of the
   given process (not counting time spent suspended by
   PAUSE). Includes garbage-collection time.
  
> (process:runtime/milliseconds process)

   Returns a FrTime time-varying value which counts the
   number of milliseconds elapsed in the execution of the
   given process (not counting time spent suspended by
   PAUSE). Includes garbage-collection time.

> (process:exited? process)

   Return a time-varying Boolean value which becomes
   true after the given MzTake process exited/killed.
  

_Useful Functions for Time-Varying Values_

MzTake defines a few functions on time-varying values
that are particularly useful when debugging.


> (history-b n stream)

   Keeps a list of the last n values of a behavior
   Returns a list of at most n elements, where the
   elements are the n last values seem on the stream,
   in order, oldest first.

> (count-e stream)

   Counts number of event pings on an eventstream,
   regardless of whether the value changes or not
   (often used with ENTRY traces).

> (count-b b)

   Counts number of times a behavior's value
   updates/changes (often used with BIND traces).

> (sequence-match? seq evs)

   Matches a sequence of items in a list to the history
   of event pings, on the event stream evs.

> (printf-b format-string arg ...)

   Displays the value of the behaviors with the given format,
   using "~a" just like in Scheme's FORMAT function.


============================================================

Known Problems

* In general, you should not REQUIRE or use any methods
  in your MzTake script that were defined in any of the files
  you are putting bind-traces on:

  ORIGINAL FILE:
  (define (my-fun some-struct) ...)

  MZTAKE SCRIPT:
  (require "original-file.ss")
  (mztake-process p ("original-file.ss" [val 10 12 bind 'my-struct]))
  (my-fun (hold val))

  Sometimes this causes unusual errors. These problems usually only
  show up if you are binding to structs (defined in the same file) and
  passing those bindings to functions (defined in the same file).
 
  You have been warned.

* The break button will *not* kill runaway client processes.
  You must type (kill process-name) or (kill-all).

* Some legal syntax locations (used in setting trace points)
  are unreachable during program execution (they do not get
  triggered and produce empty eventstreams). So far, this only
  shows up in LETs (the trace point being one line above,
  and one character to the left of the carrot):

     (define x 12)
     (let ([x (add1 x)]) x)
      ^   ^^^ 
  Recommended syntax locations to use for trace points:
     (define x 12)
     (let ([x (add1 x)]) x)
     ^        ^^    ^    ^

* Don't rely completely on MzTake to complain when you change
  target code and your line/col locations in the script are out
  of date. It can only raise an error if the locations are invalid.

* Order matters -- if you have more than one kind of trace at
  an identical syntax location, the order that trace events get
  updated is currently undefined.

  For now, the hack is to add traces as follows:

       First trace:                   Second trace:
       (code ... (more-code ...))     (code ... (more-code ...))
       ^                                        ^
  Because of how Scheme is evaluated, usually nothing happens on
  the same line of between two "open" parentheses as they are
  traversed from left to right; this gives you a definite trace order.

* MzTake has not been tested for stability if the target is using
  multiple threads. This only applies to threaded modules
  *with* traces on them -- other REQUIRE'd modules will work
  as expected.

* Error handling is not perfect -- e.g., the little "bug"
  buttons on syntax errors don't reference the correct code.
  However, the messages that are printed are as accurate as
  possible.

* process:running? tells you if the process is currently,
  actively, running. It might be useful to you, and will
  be in the next release.

* On particularly fast computers, when running scripts with a
  very high trace point density (traces are hit constantly,
  potentially hundreds in a second, like in the Monte Carlo,
  random-xs, and sine demos), the FrTime animation window may
  appear unresponsive because of how fast it is redrawing.

* Currently, if you are running traces on two modules with the
  same name, IN the same process, though in different directories,
  there will probably be some sort of name-clash and strange error.
  This will be fixed.


============================================================

Tips and Tricks

* You may want to bind more than one variable at a certain point
  so that you only get one change event -- otherwise, you will
  get multiple change events even if at the same trace point
  (see Known Problems).

  For instance, if you trace 'x and 'y separately:
    * First 'x and 'y are up-to-date.
    * Then 'x updates and 'y is out-of-date.
    * Then 'y updates, and both are up-to-date.

  But code that draws using a position derived from x and y
  will draw twice, in two locations, one for each update,
  the second one being correct.

* You can trace the *same* file in different ways by using
  multiple processes on the same file, under different
  contexts, and compare results. For example, in
  "demos/misc/first-class-test.ss":

     (mztake-process p ("first-class.ss" [x-before-let 3 29 bind 'x]
                                         [x-in-let     4 25 bind 'x]
                                         [x-after-let  5 11 bind 'x]))
     (... code omitted ...)
     (start/resume p)

  is functionally equivalent to:

     (mztake-process p1 ("first-class.ss" [x-before-let 3 29 bind 'x]))
     (mztake-process p2 ("first-class.ss" [x-in-let     4 25 bind 'x]))
     (mztake-process p3 ("first-class.ss" [x-after-let  5 11 bind 'x]))
     (... code omitted ...)
     (start/resume p1) (start/resume p2) (start/resume p3)

  All the variable bindings can still be used as they were before.

* Code such as (when (= num 100) (pause p)) pauses *after*
  num reaches 100, the next time a trace point is hit.
  However, the next point is not processed until you
  START/RESUME. See the random-xs demo.

* When you pause a MzTake process, you can play with
  current bindings and explore script code interactively.
  You *may* dynamically evaluate/add FrTime code to do
  things like pause or kill a MzTake process based on runtime,
  etc. You can even define new MzTake processes dynamically
  and start/resume them, integrating and exploring the traces.
  You cannot add or change existing traces dynamically.

* You can add trace points to first-class functions, and they
  will send trace update from anywhere they are passed to and
  evaluated.

* FrTime has two methods for drawing graphics. One runs in
  constant time, and is fast, because it simply accumulates
  pixels on the screen and doesn't redraw a list of objects.
  See the "Monte Carlo" or "random-xs" demos for this in action.

  The other method is primarily for animations which need
  redrawing because things move. It slows down pretty quickly
  after you have more than 1000 objects to the shape list.
  See the "sine" or "highway" demos for this in action.

  For more information, refer to the FrTime documentation.


============================================================

Authors and Thanks 

MzTake is an experimental debugger. It should enable new
debugging approaches that were not possible (easily) before.
Please send feedback to the PLT-Scheme mailing list:
   http://www.plt-scheme.org/maillist/

We are eager to hear about how you are using MzTake!

   Jonathan Spiro
   Guillaume Marceau
   Gregory Cooper
   Shriram Krishnamurthi

---
Icons for MzTake come from the Gnome Project: Nautilus Emblems
These are provided under the GPL license.
   http://jimmac.musichall.cz/ikony.php3
