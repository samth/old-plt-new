
============================================================

  About MzTake

_MzTake_ is a scripted debugger for Plt Scheme. It
provides facilities for monitoring the execution of a
target program as it unfolds. In the future, MzTake
will also let you interact with a paused program and
inspect its state. 

MzTake scripts are written in the Frtime programming
language, which is bundled with DrScheme. FrTime is
similar to Scheme with the additions of time-varying
values and real-time event streams. With these two
constructs, it is possible to respond to outside
events, concisely without using callbacks, for example:

   (debug-process p ("highway.ss" [values-of-speed 3 5 bind 'speed]))
   (history-b 10 values-of-speed)

This MzTake script executes the file first-demo.ss in the
"module" language, and installs a watch point for the
variable "x" on line 5 (at column 8). This watch point
is named "values-of-speed", which is in turn used in the
call to "history-b". Here, "history-b" returns a list
of the last ten values of the variable x seen on line
5, over time. DrScheme displays this list in the
interaction pane, where you can use it to confirm (or
refute!) that your program is working correctly.

MzTake scripts are powerful tool for building test
suites. Whereas typical test cases can only assert that
the result of a computation is correct, MzTake scripts
can break open an execution and record its inner state
and compute with it, allowing you to confirm that the
intermediate steps that lead to a correct answer were
also correct. In the example below, we test that x
always is less than 5:

  (map (lambda (an-x) (if (< an-x 55) 'ok 'too-fast!!))
       (history-b 10 values-of-speed))

Finally, FrTime provides a rich animation
library. Combined with the MzTake debugger, it takes
only a few lines to animate your algorithms and see
them in action.

  (display-shapes (make-speed-gauge (hold values-of-speed)))


============================================================

  Running MzTake

MzTake is a DrScheme tool. DrScheme will look for
MzTake in the "collects" directory and load it
automatically, if found. Make sure you select the
"MzTake" language from DrScheme's language dialog, in
the "Experimental Languages" section. If your language
dialog does not contain "MzTake", you can install it by
downloading the ".plt" distribution file, then
selecting "Install .plt File..." from the "File" menu
in DrScheme.

    http://www.cs.brown.edu/~gmarceau/files/mztake.plt


============================================================

  Demos

The demos subdirectories contains examples for
different uses of MzTake. You should be able to run
them in DrScheme by switching to the MzTake language
and clicking the "Run" button.

  demos/highway/highway-test.ss        - small MzTake example used above

  demos/sine/sine-test.ss              - plots values extracted from the
                                         running program

  demos/montecarlo/montecarlo-test.ss  - visualizes montecarlo integration used
                                         to evaluate the value of pi

  demos/random/random-Xs-test.ss       - tests the quality of Scheme's random
                                         number generator




============================================================

  Functions

In order to use MzTake, you will first have to learn
the FrTime language. FrTime's own "doc.txt" explains
how to use time varying values and event streams, and
also describes the many functions that operate on them.

MzTake itself defines the following functions:


_Installing Watch Points_

> (mztake-process process-name
    [target-filename trace-clause ...] ...)

   where trace-clause is either

    <1>   [trace-name line-number column-number break]
    <2>   [trace-name line-number column-number bind variable-name]

   or

    <3>  [trace-name line-number column-number bind '(variable-name ...)]

   mztake-process installs watch points in one or many
   files, as indicated by the trace-clauses. The
   target-filename can be any file specification
   accepted the standard "require" syntax for
   modules. For instance, to specify a target file
   using an absolute path, use requires's "file"
   specifier:

     (mztake-process p [(file "/home/me/test.ss") [brk 10 7 break]])

   Each target-filename should define a module (MzTake
   does not support debugging top-level
   definitions). mztake-process defines the variable
   process-name, whose value is a MzTake process
   object.  That object can be passed to the process
   functions documented in the next section. In
   particular, start/resume is a function that consumes
   a MzTake process and actually lunches its
   execution. That is, start/resume calls "require" on
   the first of the target-files given in the call to
   mztake-process.

   For each trace-clause in the call to mztake-process,
   the trace-name is a variable name bound at the
   top-level, whose value is a FrTime event
   stream. Each time the execution of the target
   reaches the given line-number and column[*], the
   debugger emits an event on that stream. The value of
   that event depends on which of the three kinds of
   trace-clause was used, as follow:

   <1> the value of the event is #t

   <2> the value of the event is the value of variable-name,
       in the target program, at the location of the
       watch point.

   <3> the value of the event is a list containing one
       element for each variable name given. The value
       of each element is taken from the variable of
       that name in the target (as in <2>)

   Watch points do not themselves pause the
   program. Unless a MzTake process is suspended using
   the pause function (below), execution resumes after
   the MzTake script processed the event.

   [*] All valid syntax begins to the left of "(", "["
       or the before the first character of a symbol/name.
       See Known Issues for more information.

   [*] To obtain accurate line/column information when
       setting up watch points, make sure you turn off
       DrScheme's "Wrap Text" feature under the "Edit"
       menu. Alternatively, you can click MzTake's
       "Syntax Location" button, on the toolbar, to
       obtain the line and column number for the
       position under the cursor.
   

_Operations on MzTake Processes_

The following functions operate on MzTake processes:

> (start/resume process)

   Initiate the execution of the process, under the
   monitoring by MzTake. In general, you should install
   your monitoring before calling start/resume,
   otherwise you script may miss events from the
   beginning of the evaluation. 

   If the process given to start/resume is already
   running was paused with the function "pause", below,
   start/resume resume its execution.

> (kill process)

   Kills the target process and releases all ressources
   it used.

> (kill-all)

   kill-all kills all the processes currently running
   under MzTake.

> (pause process)

   Suspends the execution of the given debugger
   process. Use start/resume to resume execution.

> (process:exceptions process)

   Returns an event stream. If the target process
   throws an uncaught exception, the exception will
   appear of this stream.

> (process:runtime/seconds process)

   Returns a FrTime time-varying value which count the
   number of seconds elapsed in the execution of the
   given process (not counting time spent suspended by
   "pause")
  
> (process:runtime/milliseconds process)

   Returns a FrTime time-varying value which count the
   number of milliseconds elapsed in the execution of the
   given process (not counting time spent suspended by
   "pause")

> (process:exited? process)

   Return a time-varying boolean value which becomes
   true after the given MzTake process exited.
  

_Useful Functions for Time-Varying Values_

MzTake defines a few functions on time-varying values
that are particularly useful when debugging.


> (history-b n stream)

   Keeps a list of the last n values of a behavior
   Returns a list of at most n elements, where the
   elements are the n last values seem on the stream,
   in order, oldest first.

> (count-e stream)

   Counts number of event pings on an eventstream.

> (count-b b)

   Counts number of times a behavior updates/changes

> (sequence-match? seq evs)

   Matches a sequence of items in a list to the history
   of event pings, on the event stream evs.

> (printf-b format arg ...)

   Display the value of the behaviors with the given format


============================================================

Known Issues

* The break button will *not* kill runaway client processes.
  You must type (kill process-name) or (kill-all).

* Some valid join points, such as ("->"):
     (define x 12)
     (->let ->(->[>x (add1 x)]) x)
  do *not* produce any values for the bindings, just an empty
  eventstream -- particularily in "let"s.
  
  Legal (recommended) bind points ("->"):
     (define x 12)
   ->(let ([x ->(->add1 ->x)]) ->x)

* Don't rely completely on bind to complain when you change
  target code and your line/col offsets are out of date in a
  script. Sometimes you may write a bunch of code and the
  values will still be on valid syntax join points, albeit
  not the correct ones, so you get the wrong values.

* Order matters -- if you have more than one kind of trace at
  an identical syntax location, the order events occur is
  undefined.
    - You may have a bind that when updated draws a graphic,
      and a breakpoint, you may want the breakpoint to happen
      before the bind happens.

    - For now, the hack is to bind one at ->(code...)
      and the other (code...->(more-code...))
      immediately following at the next open parentheses.
      Often, not much happens on the same line between two
      valid trace points, so this gives you a definite order.

* Has not been tested for stability if the target is using
  multiple threads. This only applies to threaded modules
  *with* traces on them -- other 'require'd modules will work
  as expected.


============================================================

Misc. Tips

* You may want to bind more than one variable at a certain point
  so that you only get one change event -- otherwise, you will
  get multiple change events even if at the same tracepoint
  (see Known Issues).

  For instance, if you trace 'x and 'y seperately:
    'x 'y are up to date, then 'x updates, 'y is out of date,
    then 'y updates, and both are up to date.

  But code that draws x and y locations will draw in two places,
  one for each update.

* You can trace the *same* file in different ways by using
  multiple processes on the same file, under different
  contexts, and compare results.

* Code such as (when (= num 100) (pause p)) pauses *after*
  num reaches 100, so the pause doesn't happen until the
  101st iteration.

* When you pause a mztake-process, you can play with
  current bindings and explore script code interactively.
  You *may* dynamically evaluate/add FrTime code to do
  things like pause or kill a mztake-process based on runtime,
  etc. You can even define new mztake-processes dynamically
  and start/resume them, integrating and exploring the traces.
  You cannot add or change existing traces dynamically.

* You can add watch points to first-class functions, and they
  will send events from no matter where they are evaluated.

* FrTime has two methods for drawing graphics. One runs in
  constant time, and is fast, because it simply accumulates
  pixels on the screen and doesn't redraw a list of objects.
  See the random-xs demo for this in action.

  The other method is primarily for animations which need
  redrawing because things move. It slows down pretty quickly
  after you have more than 1000 objects to the shape list.
  See the sine demo for this in action.

  For more information, refer to the FrTime documentation.


============================================================

Authors and Thanks 

You can reach the authors of MzTake at the following
email addresses. MzTake is an experimental debugger. It
should enable new debugging approaches that were not
possible (easily) before. We are eager to hear about
how you are using MzTake.

   Guillaume Marceau:       gmarceau@cs.brown.edu
   Jonathan Spiro:          jspiro@cs.brown.edu
   Shriram Khrisnamurthy:   sk@cs.brown.edu


Icons for MzTake come from the Gnome Project: Nautilus
Emblems, used under the GPL lisence.
   http://jimmac.musichall.cz/ikony.php3
