
============================================================

  About MzTake

_MzTake_ is a _scripted debugger_ for PLT Scheme. It
helps programmers monitor the execution of a target
program as it unfolds. In the future, MzTake will
also let you interact with a paused program and
inspect its state. 

MzTake scripts are written in the FrTime programming
language, which is bundled with DrScheme. FrTime is
similar to Scheme with the additions of time-varying
values and real-time event streams. With these two
constructs, it is possible to respond to outside
events concisely (without using callbacks). Consider
the following MzTake script:

   (debug-process radar-program
                  ("highway.ss" [values-of-speed 3 4 bind 'speed]))
   (printf-b "current speed: ~a" (hold values-of-speed))
   (start/resume radar-program)

This code actually executes a target module in the file
"highway.ss" after installing a _trace point_ (also known
as a _watch point_) just before Scheme syntax on the third
line (at the fourth column) of "highway.ss". "values-of-speed"
is is a FrTime event stream that always contains the *current*
value (and potentially every past value) of the variable named
"speed", as it is bound at that point in execution/syntax.

"printf-b" works like Scheme's printf" function, consuming a
format-string and fill-values, printing the result in
DrScheme's interaction pane. Whereas "printf" accumulates
outdated text on the screen, "printf-b" will constantly replace
the old text with a newer one if any of the fill-values change.
In this invocation, it prints the current speed to screen,
throughout the execution of "highway.ss".

MzTake scripts are also powerful tools for building external
test suites. Whereas typical test cases can only assert that
the result of a computation is correct, MzTake scripts
can dynamically break open an execution, record inner state,
and *compute* with it. This allows you to confirm that the
intermediate steps which lead to a correct answer were
also correct. In the example below, we use a version of map
that works over events in an event stream. We assert that
all recorded speeds are less than 55, otherwise we raise
an exception:

  (map-e (lambda (a-speed)
                 (when (>= a-speed 55) (raise 'too-fast!!)))
         values-of-speed)

Of course, like most test suites, this only tells you
something went wrong. Perhaps knowing the last ten speeds that
led to this would prove useful. You could "printf" the value
onto a new line each time, but too many of these updates and
the screen quickly starts to fill up with useless data -- we are
only interested in the last ten speeds, afterall. Instead, why
don't we "pause" the program when this happens, and interactively
review only the ten recorded speeds we care about:

  (printf-b "last ten speeds: ~a" (history-b 10 values-of-speed))
  (map-e (lambda (a-speed)
                 (when (>= a-speed 55) (pause radar-program)))(semaphore-wait run-semaphore)
         values-of-speed)

"history-b" consumes a number and an event stream
("values-of-speed") and returns a FrTime behavior containing
a FIFO ordered list of the last ten values
seen emitted on that event stream. In this case, it contains
the ten most recent "speed"s seen during execution. DrScheme
displays this list in the interaction pane, where you can use
it to confirm (or refute!) that your program is working correctly.

Finally, FrTime provides a rich animation
library. Combined with the MzTake debugger, it takes
only a few lines to animate your algorithms and see
them in action.

  (display-shapes (make-speed-gauge (hold values-of-speed)))


============================================================

  Running MzTake

MzTake is a DrScheme tool. DrScheme will look for
MzTake in the "collects" directory and load it
automatically, if found. Make sure you select the
"MzTake" language from DrScheme's language dialog, in
the "Experimental Languages" section. If your language
dialog does not contain "MzTake", you can install it by
downloading the ".PLT" distribution file, then
selecting "Install .PLT File..." from the "File" menu
in DrScheme.

    http://www.cs.brown.edu/~gmarceau/files/mztake.PLT



============================================================

  Demos

The demos subdirectories contains examples for
different uses of MzTake. You should be able to run
them in DrScheme by switching to the MzTake language
and clicking the "Run" button.

  demos/highway/highway-test.ss        - a small MzTake example, used above


  demos/sine/sine-test.ss              - plots values extracted from the
                                         running program

  demos/djikstra/dijkstra-test.ss      - debugs a buggy implementation of 
                                         Dijkstra's algorithm

  demos/montecarlo/montecarlo-test.ss  - visualizes Monte Carlo integration
                                         used to derive the value of pi

  demos/random/random-Xs-test.ss       - tests the quality of Scheme's random
                                         number generator with a histogram



============================================================

  Functions

In order to use MzTake, you will first have to learn
the FrTime language. FrTime's own "doc.txt" explains
how to use time-varying values and event streams, and
also describes the many functions that operate on them.

MzTake itself defines the following functions:


_Installing Trace Points_

> (mztake-process process-name
    [target-filename trace-clause ...] ...)

   where trace-clause is either

    <1>   [trace-name line-number column-number break]
    <2>   [trace-name line-number column-number bind 'variable-name]

   or

    <3>  [trace-name line-number column-number bind '(variable-name ...)]

   mztake-process installs trace points in one or many
   files, as indicated by the trace-clauses. The
   target-filename can be any file specification
   accepted by the standard "require" syntax for
   modules:

   * Absolute path:
       (mztake-process p [(file "/home/me/test.ss") [brk 10 7 break]])

   * Relative path:
       (mztake-process p ["../test.ss" [brk 10 7 break]])

   * Library path:
       (mztake-process p [(lib “test.ss” “file-lib”) [brk 10 7 break]])

   Each target-filename should define a module (MzTake
   does not support debugging top-level
   definitions). mztake-process defines the variable
   process-name, whose value is a MzTake process
   object. That object can be passed to the process
   functions documented in the next section. In
   particular, start/resume is a function that consumes
   a MzTake process and starts its execution and debugging.
   That is, start/resume calls a "require" on the *first* of
   the target-files (the main-module) given in the call
   to mztake-process, assuming there will be side-effects
   that run the program in the main-module.

   The rest of the files for a mztake-process are typically
   modules used *by* the main-module, allowing you to see
   what is going on deeper than the main module. For instance,
   you want to debug my-vector.ss in the context of
   my-vector-test-cases.ss using functions from my-vector.ss.

   For each trace-clause in the call to mztake-process,
   the trace-name is a variable name bound at the
   top-level, whose value is a FrTime event
   stream. Each time the execution of the target
   reaches the given line-number and column[*], the
   debugger emits an event on that stream. The value of
   that event depends on which of the three kinds of
   trace-clause was used, as follow:

   <1> the value of the event is #t (a "break" trace)

   <2> the value of the event is the value of variable-name,
       in the target program, at the location of the
       trace point (a "bind" trace).

   <3> the value of the event is a list containing one
       element for each variable name given. The value
       of each element is taken from the variable of
       that name in the target (as in <2>)

   Trace points do not themselves pause the
   program. Unless a MzTake process is suspended using
   the pause function (below), execution resumes after
   the MzTake script processed the event.

   [*] All valid syntax begins to the left of "(", "["
       or the before the first character of a symbol/name.
       See Known Issues for more information.

   [*] To obtain accurate line/column information when
       setting up trace points, make sure you turn off
       DrScheme's "Wrap Text" feature under the "Edit"
       menu. Alternatively, you can click MzTake's
       "Syntax Location" button, on the toolbar, to
       obtain the line and column number for the
       position under the cursor.
   

_Operations on MzTake Processes_

The following functions operate on MzTake processes, and
can be used interactively in the interactions pane.

> (start/resume process-name)

   Start the execution and monitoring of the mztake-process,
   process-name. If the process given to start/resume is already
   running, and was paused with the function "pause" (below),
   start/resume resumes its execution.

   Script statements are executed top-down, sequentially.
   In general, you want to call start/resume at the end of
   the script, or in the interactions pane after you
   started the script -- in either case, after you have done
   all processing. Otherwise your script may miss events
   from the beginning of the evaluation. 

> (pause process)

   Suspends the execution of the given mztake
   process. Use start/resume to resume execution.

> (kill process)

   Kills the target process and releases all resources
   it used -- you cannot start/resume after a kill.

   Closing a FrTime animation/graphics window will *not*
   kill a running program, you must kill it by hand in the
   interaction pane.

> (kill-all)

   kill-all kills all the processes currently running
   under MzTake - use this when it seems a process is
   out of control and needs to be stopped immediately.
   Has the same effect of calling kill on each process
   you defined and start/resume'd in the script.

> (process:exceptions process)

   Returns an event stream. If the target process
   throws an uncaught exception, the exception will
   appear on this stream.

> (process:runtime/seconds process)

   Returns a FrTime time-varying value which counts the
   number of seconds elapsed in the execution of the
   given process (not counting time spent suspended by
   "pause"). Includes garbage-collection time.
  
> (process:runtime/milliseconds process)

   Returns a FrTime time-varying value which count the
   number of milliseconds elapsed in the execution of the
   given process (not counting time spent suspended by
   "pause"). Includes garbage-collection time.

> (process:exited? process)

   Return a time-varying Boolean value which becomes
   true after the given MzTake process exited/killed.
  

_Useful Functions for Time-Varying Values_

MzTake defines a few functions on time-varying values
that are particularly useful when debugging.


> (history-b n stream)

   Keeps a list of the last n values of a behavior
   Returns a list of at most n elements, where the
   elements are the n last values seem on the stream,
   in order, oldest first.

> (count-e stream)

   Counts number of event pings on an eventstream,
   regardless of whether the value changes or not
   (used often with "break" traces).

> (count-b b)

   Counts number of times a behavior's value
   updates/changes (used often with "bind" traces).

> (sequence-match? seq evs)

   Matches a sequence of items in a list to the history
   of event pings, on the event stream evs.

> (printf-b format-string arg ...)

   Displays the value of the behaviors with the given format,
   using "~a" just like in Scheme's "format" function.


============================================================

Known Issues

* This is rather subtle, but very important:
  
  - You have a struct, my-struct, and a function, do-fun
    (do-fun takes a my-struct) in prog.ss.

  - You are debugging the same prog.ss, and add a trace that
    binds to the latest my-struct in some test cases at the
    end of prog.ss.

  - In the script, you want to use do-fun on the the binding,
    so you (require "my-prog.ss") at the top of the script.

  - When you try to run this, you get an error that there are
    conflicting structs called my-struct.

  - This is a known problem, and currently there is no solution.
    If this is an issue, we recommend performing the operation
    with do-fun within the test cases and binding to the result,
    or putting traces into do-fun itself, to watch it work.

  - Technical reason:
    The debugger executes code in a different (protected)
    namespace than the script is executed in. So even though
    *you* know the structs are the same, Scheme plays it safe
    and says they are different, because though they have the
    same format, they come from two different namespaces.

* The break button will *not* kill runaway client processes.
  You must type (kill process-name) or (kill-all).

* Some valid join points, such as ("->"):
     (define x 12)
     (->let ->(->[>x (add1 x)]) x)
  do *not* produce any values for the bindings, just an empty
  eventstream -- particularly in "let"s.
  
  Legal (recommended) bind points ("->"):
     (define x 12)
   ->(let ([x ->(->add1 ->x)]) ->x)

* Don't rely completely on bind to complain when you change
  target code and your line/col offsets are out of date in a
  script. Sometimes you may write a bunch of code and the
  values will still be on valid syntax join points, albeit
  not the correct ones, so you get the wrong values.

* Order matters -- if you have more than one kind of trace at
  an identical syntax location, the order events occur is
  undefined.
    - You may have a bind that when updated draws a graphic,
      and a breakpoint, you may want the breakpoint to happen
      before the bind happens.

    - For now, the hack is to bind one at (“->”) ->(code...)
      and the other at (code...->(more-code...))
      immediately following at the next open parentheses.
      Often, not much happens on the same line between two
      valid trace points, so this gives you a definite order.

* Has not been tested for stability if the target is using
  multiple threads. This only applies to threaded modules
  *with* traces on them -- other 'require'd modules will work
  as expected.

* Error handling is not perfect -- e.g., the little "bug"
  buttons on syntax errors don't reference the correct code.
  However, the messages that are printed are as accurate as
  possible.

* process:running? tells you if the process is currently,
  actively, running. It might be useful to you, and will
  be in the next release.


============================================================

Tips and Tricks

* You may want to bind more than one variable at a certain point
  so that you only get one change event -- otherwise, you will
  get multiple change events even if at the same trace point
  (see Known Issues).

  For instance, if you trace 'x and 'y separately:
    'x and 'y are up to date, then 'x updates, 'y is out of date,
    then 'y updates, and both are up to date.

  But code that draws x and y locations will draw in two places,
  one for each update.

* You can trace the *same* file in different ways by using
  multiple processes on the same file, under different
  contexts, and compare results.

* Code such as (when (= num 100) (pause p)) pauses *after*
  num reaches 100, the next time a trace point is hit.
  However, the next point is not processed until you
  "start/resume".  See the random-xs demo.

* When you pause a mztake-process, you can play with
  current bindings and explore script code interactively.
  You *may* dynamically evaluate/add FrTime code to do
  things like pause or kill a mztake-process based on runtime,
  etc. You can even define new mztake-processes dynamically
  and start/resume them, integrating and exploring the traces.
  You cannot add or change existing traces dynamically.

* You can add trace points to first-class functions, and they
  will send events from no matter where they are evaluated.

* FrTime has two methods for drawing graphics. One runs in
  constant time, and is fast, because it simply accumulates
  pixels on the screen and doesn't redraw a list of objects.
  See the Monte Carlo, or random-xs demo for this in action.

  The other method is primarily for animations which need
  redrawing because things move. It slows down pretty quickly
  after you have more than 1000 objects to the shape list.
  See the sine demo for this in action.

  For more information, refer to the FrTime documentation.


============================================================

Authors and Thanks 

You can reach the authors of MzTake at the following
email addresses. MzTake is an experimental debugger. It
should enable new debugging approaches that were not
possible (easily) before. We are eager to hear about
how you are using MzTake.

   Jonathan Spiro:          jspiro@cs.brown.edu
   Guillaume Marceau:       gmarceau@cs.brown.edu
   Shriram Krishnamurthi:   sk@cs.brown.edu


Icons for MzTake come from the Gnome Project: Nautilus
Emblems, used under the GPL license.
   http://jimmac.musichall.cz/ikony.php3
