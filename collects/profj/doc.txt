_professorj_

This documentation details available resources, recent additions, and
constructs which do not currently work in ProfessorJ overall. For
details of the specific language levels, please see the language level
specific manuals.

The interactions window accepts variable declaration, statements and
expressions legal for the language level. If the text is not sending,
type Alt+Enter.

The definitions window expects class and interface definitions,
interaction boxes, and test-suite boxes. (i.e. what would be given to
javac plus two graphical boxes). Descriptions of these boxes can be
found in the DrScheme manual.

_Java + dynamic_ language level
 Version 299.200 +
 This language level allows programs to contain a value that will be 
 checked dynamically rather than statically.
 
 The following code presents the use of a dynamically typed value, that
 will be checked during execution.
 
 class RuntimeCheck {
  int checkForNumber( dynamic var ) {
     return var;
  }
 }
 In RuntimeCheck, var will be checked to be an integer when checkForNumber
 is executed. Values declared with type 'dynamic' can also be used as
 any primitive or object value in Java. In addition, values with type
 'dynamic' can also be used as methods: var() is a legal use.
 
 In general, variables declared with type 'dynamic' will generate a contract
 check with coercians at each usage to ensure consistency with the Java type
 system.
 
 A Java String will be converted to a Scheme string, and vice-versa.
 
 Within the Java + dynamic language level, Scheme libraries may be 
 imported and used within the Java program.
 
 The import form is either:
   import scheme.lib.$PATH$;
   import scheme.$PATH$;
 where $PATH$ is the set of directories that leads to the Scheme module, ending
 with the modules name. The lib form is used to access Scheme modules within the
 collects hierarchy.
 The Scheme require statement (require (lib "compile.ss" "profj")) would be written
   import scheme.lib.profj.compile;
 within Java + dynamic
 
 Values provided by the scheme libraries may be used within a Java program, with
 access to them treated as though the Scheme module were a class and the provided
 value a static member. If the compile module mentioned above provides a types
 function, this would be accessed with the following code:
   ... compile.types() ...
 This value has type dynamic within the Java program, and will be dynamically checked
 based on use.
 
 As many Scheme names are not valid Java names, the following automatic name translations
 will be used:
 JName = [a-zA-Z0-9_]
   Scheme name        <->   Java name
   JName*-[a-zA-Z0-9] <-> JName*[A-Z0-9]   i.e. make-foo      <->   makeFoo
   JName*?            <-> JName*P          i.e. foo?          <->   fooP
   JName*->[a-zA-Z0-9]<-> JName*To[A-Z0-9] i.e. foo->string   <->   fooToString
   JName*!            <-> JName*Set        i.e. set-foo-baz!  <->   setFooBazSet
   JName*%            <-> Jname*Obj        i.e. object%       <->   objectObj
   
 
_Libraries available to ProfessorJ:

*NEW* Items are new to either DrScheme 207 or DrScheme 208

  java.lang.Object
  java.lang.String (see exceptions)
  java.lang.Throwable
  java.lang.*Exception
  *NEW* java.lang.System (only currentTimeMillis, gc, and identityHashCode)
  *NEW* java.lang.Comparable
  *NEW* java.lang.Number
  *NEW* java.lang.Double (see exceptions) 
  *NEW* java.lang.Float (see exceptions) 
  *NEW* java.lang.Boolean (see exceptions) 
  *NEW* java.io.Serializable
  *NEW* java.util.Random

  *NEW* Teachpacks (PLT/collects/htdch)
  *NEW* draw.*

  exceptions:
   String: String(byte[],int,int,String) -- incorrect
           String(byte[],int,int,int) -- incorrect
           getBytes() -- partially incorrect
           replaceAll(String,String) -- not implemented
           replaceFirst(String,String) -- not implemented
           matches(String) -- not implemented
           split(String,int) -- not implemented
           split(String) -- not implemented
           trim -- not implemented
   Double: doubleToLongBits -- not implemented
           doubleToRawBits -- not implemented
           longBitsToDouble -- not implemented
   Float:  floatToIntBits, floatToRawBits, longBitsToFloat -- not implemented
   Boolean: getBoolean(String) not implemented

_General New Items (New to 207 and 208)

  New to all teaching language levels:
    import package.name.*;
    a teachpack directory (PLT/collects/htdch)
    access to draw.* teachpack

  New to Beginner:
    super calls reallowed. For example
      class A { 
        int x;
        A(int x) {
          this.x = x;
        }
        int adder() { return x + 1; }
      }
      class B extends A {
        int y;
        B( int x, int y) {
          super(x);
          this.y = y;
        }
        int adder() { return y + super.adder(); }
      }
    now works
 
    == is restricted to comparing byte, short, int, long, char, and boolean
    values

    Classes may have initialized fields (i.e. int x = 3;)

_Unfinished constructs:
  nested classes
  switch
  labeled statements (compiles but does not work correctly)
  reflection
  unicode
  synchronized (compiles but is ignored)
  strictfp (compiles but is ignored)







