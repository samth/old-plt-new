
The _r6rs_ collection contains support for things that might become
part of the R6RS standard.


To write an R6RS library:
 
 #reader(lib "library.ss" "r6rs")
 (library "name" ....)

where "name" matches the containing file name without the file path or
suffix. Note that the #reader line adjusts reader syntax in addition
to converting `library' to `module'.


To evaluate R6RS `library' and `import' forms at the REPL (or with
`load', etc):

 > (require (lib "library-repl.ss" "r6rs"))

or start MzScheme as

 % mzscheme -L library-repl.ss r6rs


In either mode, to import a collection-based module to to reference
other libraries installed in the collection tree, use

 "scheme://<collection>/...<collection>/<file>"

instead of

 (lib "<file>" "<collection>" ... "<collection>")

A "scheme://" URI must have at least one <collection> and a <file> to
be translated to a `lib' reference. If the indicated collection does
not exist, a path is invented based on the "mzlib" collection; this
supports absolute URIs that name `library's entered in the REPL.


Limitations:

 - doesn't enforce that a for-run import isn't also
   a for-expand import in a different import-spec

 - doesn't enforce that idenfiers in a macro expansion
   are only the ones declared by indirect-export

 - doesn't check that an identifiers in an indirect-export
   declaration are actually defined

 - reader adjusts only string, character, and quoted-symbol
   syntax (as in SRFI-75), for now


To appear:

 - a tool to take a sequence of `library' declarations and
   copy them into the collection tree (adjusting the
   declared library name as necessary, and adding the #reader
   line)
